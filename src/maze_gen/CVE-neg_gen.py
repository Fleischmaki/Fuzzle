import smt2_parser
import random
import transforms

class Generator:
    def __init__(self, size, edges, sln, smt_file, transformations):
        self.size = size
        self.edges = edges
        self.sln = sln
        self.transformations = transformations
        
        try:
            self.constraints, self.vars_all, self.array_size = smt2_parser.parse(smt_file, check_neg = True, generate_well_defined=transformations['wd'])
        except ValueError as e:
            print('Error while parsing smt file %s' % str(e))
            self.constraints = {}
            self.vars_all = {}
            self.array_size = 0

        transforms.remove_constraints(self.constraints, transformations['dc'])
        transforms.make_const(self.vars_all, transformations['mc'])

        self.groups, self.vars = smt2_parser.independent_formulas(self.constraints, self.vars_all)

        if transformations['sh']:
            self.groups, self.vars = transforms.coshuffle(self.groups, self.vars)

        self.insert = list()
        for _ in range(self.size):
            self.insert.append(0)
        while sum(self.insert) < len(self.groups):
            for func in self.sln:
                self.insert[func] += 1
                if sum(self.insert) >= len(self.groups):
                    break
        
        if transformations['sh']:
            random.shuffle(self.insert)

    def get_logic_def(self):
        logic_def = ""
        logic_def += ("\n\n//Helper functions for division and casts\n")
        logic_def += ("""long scast_helper(unsigned long i, unsigned char width){
    if((i & (1ULL << (width-1))) > 0){
        return (long) (i - (1ULL<< width));
    }
    return i;
}\n""")
        if self.transformations['wd']:
            logic_def += ("""unsigned long sdiv_helper(long l, long r, int width){
    if(r == 0){
        if(l >= 0)
            return -1ULL >> (64-width); // Make sure we shift with 0s
        return 1;
    } else if ((r == -1) && (l == ((-0x7FFFFFFFFFFFFFFFLL-1) >> (64-width))))
        return 0x8000000000000000ULL;
    return l / r;
}
unsigned long div_helper(unsigned long l, unsigned long r, int width){
    if(r == 0)
        return -1ULL >> (64-width);
    return l / r;
}
unsigned long srem_helper(long l, long r, int width){
    if(r == 0)
        return l;
    return l % r;
}
unsigned long rem_helper(unsigned long l, unsigned long r, int width){
    if(r == 0)
        return l;
    return l % r;
}\n""")
        if self.array_size != 0:
            logic_def += "\n\n//Array support\n"
            logic_def += "#define ARRAY_SIZE %d\n" % self.array_size
            logic_def += """long* value_store(long* a,long pos,long v){
    a[pos] = v;
    return a;\n}\n"""
            logic_def += """long* array_store(long* a,long pos,long* v, int size){
    for (int i=0;i<size;i++){
        a[pos*size+i] = v[i];
    }
    return a;\n}\n"""
            logic_def += ("""int array_comp(long* a1, long* a2, int size){
    for(int i = 0; i < size; i++){
    \tif(a1[i] != a2[i]) return 0;
    }
    return 1;\n}\n""")
            logic_def += ("""void init(long* array,int size){
    for(int i = 0; i < size; i++){
    \tarray[i] = __VERIFIER_nondet_long();
    }\n}""")
        return logic_def

    def get_numb_edges(self, idx):
        return len(self.edges[idx])

    def get_groups(self, idx, group_idx):
        numb_edges = self.get_numb_edges(idx)
        print(self.groups)
        if self.insert[idx] == 0:
            group, vars = smt2_parser.get_subgroup(self.groups, self.vars, idx)
            negated_groups, new_vars = smt2_parser.get_negated(self.constraints, group, vars, numb_edges - 1)
        else:
            group, vars = list(), set()
            for cnt in range(self.insert[idx]):
                group = group.union(self.groups[group_idx + cnt])
                vars = vars.union(self.vars[group_idx + cnt])
            negated_groups, new_vars = smt2_parser.get_negated(self.constraints, group, vars, numb_edges - 2)
        return group, vars.union(new_vars), negated_groups

    def get_bug_edge(self, idx):
        next, bug_edge, = 0, 0
        for i in range(len(self.sln)):
            if self.sln[i] == idx:
                if i == len(self.sln) - 1:
                    next = 'bug'
                else:
                    next = self.sln[i+1]
        for n in range(len(self.edges[idx])):
            if self.edges[idx][n] == next:
                bug_edge = n
        return bug_edge

    def get_logic_c(self):
        logic_c = list()
        group_idx = 0
        for idx in range(self.size):
            group, vars, negated_groups = self.get_groups(idx, group_idx)
            logic = ""
            for var in vars:
                logic += self.get_initialization(var)
            logic += "\t\tint flag = 0;\n"

            if self.insert[idx] == 0:
                for n in range(len(negated_groups)):
                    tab_cnt = 0
                    for constraint in negated_groups[n]:
                        logic += "\t"*tab_cnt + "\t\tif{}{{\n".format(constraint)
                        tab_cnt += 1
                    logic += "\t"*tab_cnt + "\t\tflag = {};\n".format(n + 1)
                    for k in range(len(negated_groups[n])-1, -1, -1):
                        logic += "\t"*k + "\t\t}\n"
            else:
                numb_edges = self.get_numb_edges(idx)
                bug_edge = self.get_bug_edge(idx)
                tab_cnt = 0
                # function call towards func_bug
                for constraint in group:
                    logic += "\t"*tab_cnt + "\t\tif{}{{\n".format(constraint)
                    tab_cnt += 1
                if bug_edge == numb_edges - 1 and bug_edge > 0:
                    logic += "\t"*tab_cnt + "\t\tflag = {};\n".format(bug_edge)
                else:
                    logic += "\t"*tab_cnt + "\t\tflag = {};\n".format(bug_edge + 1)
                for k in range(len(group)-1, -1, -1):
                    logic += "\t"*k + "\t\t}\n"
                # rest of function calls
                for n in range(len(negated_groups)):
                    tab_cnt = 0
                    for constraint in negated_groups[n]:
                        logic += "\t"*tab_cnt + "\t\tif{}{{\n".format(constraint)
                        tab_cnt += 1
                    if n >= bug_edge:
                        logic += "\t"*tab_cnt + "\t\tflag = {};\n".format(n + 2)
                    else:
                        logic += "\t"*tab_cnt + "\t\tflag = {};\n".format(n + 1)
                    for k in range(len(negated_groups[n])-1, -1, -1):
                        logic += "\t"*k + "\t\t}\n"
            logic_c.append(logic)
            group_idx += self.insert[idx]
        return logic_c

    def get_initialization(self, var):
        if '[' in var: #Arrays
            dim = var.count('[')
            return "\t{} {};\n\tinit({}{},{});\n".format(self.vars_all[var],var,'*'*(dim-1),var.split('[')[0],smt2_parser.get_array_size_from_dim(dim))
        elif self.vars_all[var] == 'bool':
            return "\t_Bool {} = __VERIFIER_nondet_bool();\n".format(var)
        elif self.vars_all[var] == 'const bool':
            return "\t const _Bool {} = __VERIFIER_nondet_bool();\n".format(var)
        else:
            orig_type = self.vars_all[var]
            short_type = orig_type.split(" ")[-1]
            if 'unsigned' in orig_type:
                short_type = 'u' + short_type
            return "\t{} {} = __VERIFIER_nondet_{}();\n".format(self.vars_all[var], var, short_type)


    def get_numb_bytes(self):
        numb_bytes = list()
        group_idx = 0
        for idx in range(self.size):
            _, vars, _, = self.get_groups(idx, group_idx)
            numb_bytes.append(len(vars))
            group_idx += self.insert[idx]
        return numb_bytes

    def get_guard(self):
        guard = list()
        for idx in range(self.size):
            numb_edges = self.get_numb_edges(idx)
            conds = []
            if self.insert[idx] == 0:
                for n in range(numb_edges - 1):
                    conds.append("flag == " + str(n + 1))
                conds.append("flag == 0")
                guard.append(conds)
            else:
                bug_edge = self.get_bug_edge(idx)
                if bug_edge == numb_edges - 1:
                    if bug_edge == 0:
                        conds.append("flag == 1")
                    else:
                        for n in range(numb_edges - 2):
                            conds.append("flag == " + str(n + 1))
                        conds.append("flag == 0")
                        conds.append("flag == " + str(bug_edge))
                else:
                    for n in range(numb_edges - 1):
                        conds.append("flag == " + str(n + 1))
                    conds.append("flag == 0")
                guard.append(conds)
        return guard

    def get_total_bytes(self):
        return sum(self.get_numb_bytes())